<h1>ActiveColumn</h1>

<p>ActiveColumn is a framework for saving and retrieving data from Cassandra in a "time line" model.  It is loosely based
on concepts in ActiveRecord, but is adapted to saving data in which rows in Cassandra grow indefinitely over time, such
as in the oft-used Twitter example for Cassandra.</p>

<h2>Installation</h2>

<p>Add ActiveColumn to your Gemfile:</p>

<pre>
gem 'active_column'
</pre>

<p>Install with bundler:</p>

<pre>
bundle install
</pre>

<h2>Usage</h2>

<h3>Configuration</h3>

<p>ActiveColumn requires the <a href="https://github.com/fauna/cassandra">cassandra gem</a>.  You must provide ActiveColumn with an
instance of a Cassandra object.  You can do this very simply like this:</p>

<pre>
ActiveColumn.connection = Cassandra.new('my_keyspace', '127.0.0.1:9160')
</pre>

<p>However, in a real app this is not flexible enough, so I often create a cassandra.yml file and configure Cassandra in an
initializer.</p>

<p>config/cassandra.yml</p>

<pre>
test:
  home: ":"
  servers: "127.0.0.1:9160"
  keyspace: "myapp_test"
  thrift:
    timeout: 3
    retries: 2

development:
  home: ":"
  servers: "127.0.0.1:9160"
  keyspace: "myapp_development"
  thrift:
    timeout: 3
    retries: 2
</pre>

<p>config/initializers/cassandra.rb</p>

<pre>
config = YAML.load_file(Rails.root.join("config", "cassandra.yml"))[Rails.env]
$cassandra = Cassandra.new(config['keyspace'],
                           config['servers'],
                           config['thrift'])

ActiveColumn.connection = $cassandra
</pre>

<p>As you can see, I create a global $cassandra variable, which I use in my tests to validate data directly in Cassandra.</p>

<p>One other thing to note is that you obviously must have Cassandra installed and running!  Please take a look at the
<a href="https://github.com/carbonfive/mama_cass">mama_cass gem</a> for a quick way to get up and running with Cassandra for
development and testing.</p>

<h3>Saving data</h3>

<p>To make a model in to an ActiveColumn model, just extend ActiveColumn::Base, and provide two pieces of information:
* Column Family
* Function(s) to generate keys for your rows of data</p>

<p>The most basic form of using ActiveColumn looks like this:</p>

<pre>
class Tweet &lt; ActiveColumn::Base
  column_family :tweets
  keys :user_id
end
</pre>

<p>Then in your app you can create and save a tweet like this:</p>

<pre>
tweet = Tweet.new( :user_id => 'mwynholds', :message => "I'm going for a bike ride" )
tweet.save
</pre>

<p>When you run #save, ActiveColumn saves a new column in the "tweets" column family in the row with key "mwynholds".  The
content of the row is the Tweet instance JSON-encoded.</p>

<p><em>Key Generator Functions</em></p>

<p>This is great, but quite often you want to save the content in multiple rows for the sake of speedy lookups.  This is
basically de-normalizing data, and is extremely common in Cassandra data.  ActiveColumn lets you do this quite easily
by telling it the name of a function to use to generate the keys during a save.  It works like this:</p>

<pre>
class Tweet &lt; ActiveColumn::Base
  column_family :tweets
  keys :user_id => :generate_user_keys

  def generate_user_keys
    [ attributes[:user_id], 'all']
  end
end
</pre>

<p>The code to save the tweet is the same as the previous example, but now it saves the tweet in both the "mwynholds" row
and the "all" row.  This way, you can pull out the last 20 of all tweets quite easily (assuming you needed to do this
in your app).</p>

<p><em>Compound Keys</em></p>

<p>In some cases you may want to have your rows keyed by multiple values.  ActiveColumn supports compound keys,
and looks like this:</p>

<pre>
class TweetDM &lt; ActiveColumn::Base
  column_family :tweet_dms
  keys [ { :user_id => :generate_user_keys }, { :recipient_id => :recipient_ids } ]

  def generate_user_keys
    [ attributes[:user_id], 'all ]
  end
end
</pre>

<p>Now, when you create a new TweetDM, it might look like this:</p>

<pre>
dm = TweetDM.new( :user_id => 'mwynholds', :recipient_ids => [ 'fsinatra', 'dmartin' ], :message => "Let's go to Vegas" )
</pre>

<p>This tweet direct message will saved to four different rows in the "tweet_dms" column family, under these keys:
* mwynholds:fsinatra
* mwynholds:dmartin
* all:fsinatra
* all:dmartin</p>

<p>Now my app can pretty easily figure find all DMs I sent to Old Blue Eyes, or to Dino, and it can also easily find all
DMs sent from <em>anyone</em> to Frank or Dino.</p>

<p>One thing to note about the TweetDM class above is that the "keys" configuration at the top looks a little uglier than
before.  If you have a compound key and any of the keys have custom key generators, you need to pass in an array of
single-element hashes.  This is in place to support Ruby 1.8, which does not have ordered hashes.  Making sure the keys
are ordered is necessary to keep the compounds keys canonical (ie: deterministic).</p>

<h3>Finding data</h3>

<p>Working on this...</p>
